# JavaScript模块化发展 
 [JavaScript模块化开发的演进历程 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000015302578)

### 1. 闭包与命名空间
    这是最容易想到的也是最简便的解决方式，早在模块化概念提出之前很多人就已经使用闭包的方式来解决变量重名和污染问题。这样每个js文件都是使用IIFE包裹的，各个js文件分别在不同的词法作用域中，相互隔离，最后通过闭包的方式暴露变量。每个闭包都是单独一个文件，每个文件仍然通过script标签的方式下载，标签的顺序就是模块的依赖关系。

各个js文件之间避免了变量重名干扰，并且最少的暴露变量，避免全局污染。
模块外部不能轻易的修改闭包内部的变量，程序的稳定性增加。
模块与外部的连接通过IIFE传参，语义化更好，清晰地知道有哪些依赖。


### 2. 面向对象开发

一开始一些人在闭包的解决方案上做出了规范约束：每个js文件始终返回一个object，将内容作为object的属性。  
及时返回的是个值，也要用object包裹。后来很多人开始使用面向对象的方式开发插件：

    1.规范化输出，更加统一的便于相互依赖和引用。
    2.使用‘类’的方式开发，便于后面的依赖进行扩展。
    本质上这种方法只是对闭包方法的规范约束，并没有做什么根本改动。

### 3. CommonJs(node)同步加载模块

    原生Module对象，每个文件都是一个Module实例
    文件内通过require对象引入指定模块
    所有文件加载均是同步完成
    通过module关键字暴露内容
    每个模块加载一次之后就会被缓存
    模块编译本质上是沙箱编译
    由于使用了Node的api，只能在服务端环境上运行



    优点：
    简单容易使用
    服务器端模块便于复用

    缺点:
    同步加载方式不适合在浏览器环境中使用，同步意味着阻塞加载，浏览器资源是异步加载的
    不能非阻塞的并行加载多个模块
    ？为什么浏览器不能使用同步加载，服务端可以？

    因为模块都放在服务器端，对于服务端来说模块加载时
    而对于浏览器端，因为模块都放在服务器端，加载的时间还取决于网速的快慢等因素，如果需要等很长时间，整个应用就会被阻塞。
    因此，浏览器端的模块，不能采用"同步加载"（CommonJs），只能采用"异步加载"（AMD）。
    参照CommonJs模块代表node.js的模块系统

###   4. AMD和RequireJS
AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"
Commonjs的诞生给js模块化发展有了重要的启发，Commonjs非常受欢迎，但是局限性很明显：Commonjs基于Node原生api在服务端可以实现模块同步加载，但是仅仅局限于服务端，客户端如果同步加载依赖的话时间消耗非常大，所以需要一个在客户端上基于Commonjs但是对于加载模块做改进的方案，于是AMD规范诞生了。

    RequireJs有两个最鲜明的特点：
    依赖前置：动态创建<script>引入依赖，在<script>标签的onload事件监听文件加载完毕；一个模块的回调函数必须得等到所有依赖都加载完毕之后，才可执行，类似Promise.all。
    配置文件：有一个main文件，配置不同模块的路径，以及shim不满足AMD规范的js文件。
    还是上面那个例子


### 5. CMD和SeaJs
    define定义模块，require加载模块，exports暴露变量。
    不同于AMD的依赖前置，CMD推崇依赖就近（需要的时候再加载）
    推崇api功能单一，一个模块干一件事。


    SeaJs核心特点：

    需要配置模块对应的url。
    入口文件执行之后，根据文件内的依赖关系整理出依赖树，然后通过插入<script>标签加载依赖。
    依赖加载完毕之后，执行根factory。
    在factory中遇到require，则去执行对应模块的factory，实现就近依赖。
    类似Commonjs，对所有模块进行缓存（模块的url就是id）。
    类似Commonjs，可以使用相对路径加载模块。
    可以向RequireJs一样前置依赖，但是推崇就近依赖。
    exports和return都可以暴露变量。

### 7. ES6中的模块化
    可以看到，ES6中的模块化在Commonjs的基础上有所不同，增加了关键字import，export，default，as，from，而不是全局对象。另外深入理解的话，有两点主要的区别：
    CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
    CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。